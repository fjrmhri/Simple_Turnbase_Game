<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Celestia Clash - Turn Battle</title>
    <style>
      @font-face {
        font-family: "Monocraft";
        src: url("fonts/Monocraft.otf") format("opentype"),
          url("fonts/Monocraft.ttf") format("truetype");
      }

      :root {
        --space: #050912;
        --panel: rgba(18, 26, 48, 0.8);
        --card: rgba(23, 32, 60, 0.9);
        --line: rgba(116, 240, 237, 0.3);
        --hp: linear-gradient(90deg, #ff8f70, #ff3d3d);
        --mp: linear-gradient(90deg, #74b9ff, #0984e3);
        --accent: #ff6b6b;
        --primary: #74f0ed;
        --secondary: #ffc857;
        --text: #e3ecff;
        --muted: #9eb0d3;
        --shadow: 0 20px 45px rgba(5, 9, 18, 0.55);
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Monocraft", monospace;
        font-size: 14px;
        background: radial-gradient(
            circle at 20% 20%,
            rgba(116, 240, 237, 0.14),
            transparent 28%
          ),
          radial-gradient(
            circle at 80% 15%,
            rgba(255, 200, 87, 0.12),
            transparent 32%
          ),
          radial-gradient(
            circle at 35% 70%,
            rgba(255, 107, 107, 0.12),
            transparent 26%
          ),
          linear-gradient(180deg, #070b18, #050912 55%, #05060f);
        color: var(--text);
        min-height: 100vh;
        overflow-x: hidden;
      }

      .game-shell {
        position: relative;
        min-height: 100vh;
        width: 100%;
        display: flex;
        flex-direction: column;
      }

      .start-screen {
        position: fixed;
        inset: 0;
        background: radial-gradient(
            circle at 50% 30%,
            rgba(116, 240, 237, 0.25),
            transparent 40%
          ),
          radial-gradient(
            circle at 70% 70%,
            rgba(255, 107, 107, 0.2),
            transparent 45%
          ),
          rgba(5, 9, 18, 0.92);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 200;
      }

      .start-panel {
        background: var(--card);
        padding: 28px 36px;
        border-radius: 16px;
        border: 1px solid var(--line);
        box-shadow: var(--shadow);
        text-align: center;
        width: min(430px, 90vw);
      }

      .start-panel h1 {
        font-size: 2.2rem;
        color: var(--primary);
        text-shadow: 0 10px 26px rgba(116, 240, 237, 0.35);
      }

      .start-panel p {
        margin: 8px 0 18px;
        color: var(--muted);
      }

      .start-button {
        padding: 11px 24px;
        background: linear-gradient(
          135deg,
          rgba(116, 240, 237, 0.9),
          rgba(116, 240, 237, 0.65)
        );
        color: #03101c;
        border: none;
        border-radius: 12px;
        font-weight: 700;
        font-size: 1rem;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 0 12px 22px rgba(116, 240, 237, 0.35);
      }

      .start-button:hover {
        transform: translateY(-2px);
      }

      .battle-field {
        flex: 1;
        position: relative;
        overflow-x: hidden;
        overflow-y: auto;
      }

      .nebula {
        position: absolute;
        inset: 0;
        background: radial-gradient(
            circle at 50% 10%,
            rgba(116, 240, 237, 0.12),
            transparent 40%
          ),
          radial-gradient(
            circle at 52% 80%,
            rgba(255, 107, 107, 0.12),
            transparent 35%
          ),
          radial-gradient(
            circle at 20% 50%,
            rgba(255, 200, 87, 0.12),
            transparent 45%
          );
        filter: blur(20px);
        z-index: 1;
      }

      .battle-layer {
        position: relative;
        z-index: 2;
        width: 100%;
        min-height: 100vh;
        display: grid;
        grid-template-rows: auto 1fr auto;
        gap: 8px;
        padding: 2px 0 10px;
      }

      .turn-order {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        padding-top: 10px;
      }

      .turn-track {
        position: relative;
        width: 500px;
        max-width: 78vw;
        height: 58px;
      }

      .turn-line {
        position: absolute;
        inset: 50% 0 0 0;
        height: 2px;
        background: var(--line);
      }

      .turn-nodes {
        position: absolute;
        inset: 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .turn-node {
        width: 52px;
        height: 52px;
        border-radius: 50%;
        border: 2px solid var(--line);
        background: rgba(255, 255, 255, 0.05);
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        box-shadow: 0 12px 22px rgba(0, 0, 0, 0.35);
        transition: transform 0.25s ease, border-color 0.25s ease,
          box-shadow 0.25s ease;
      }

      .turn-node.active {
        transform: scale(1.05) translateY(-4px);
        border-color: var(--primary);
        box-shadow: 0 16px 28px rgba(116, 240, 237, 0.25);
      }

      .turn-node img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .dragon-area {
        position: relative;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding-top: 8px;
        width: min(460px, 100%);
      }

      .boss-card {
        margin: 0 auto;
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 14px;
        width: 310px;
        max-width: 100%;
        padding: 12px;
        box-shadow: var(--shadow);
      }

      .boss-top {
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .boss-avatar {
        width: 88px;
        height: 88px;
        border-radius: 12px;
        overflow: hidden;
        background: #0c142f;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .boss-avatar img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      .boss-meta h2 {
        color: var(--secondary);
        letter-spacing: 1px;
        font-size: 1.2rem;
      }

      .meter {
        margin-top: 6px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 9px;
        padding: 6px;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .meter-label {
        display: flex;
        justify-content: space-between;
        color: var(--muted);
        font-size: 0.82rem;
        margin-bottom: 5px;
      }

      .meter-bar {
        width: 100%;
        height: 10px;
        background: rgba(8, 12, 26, 0.7);
        border-radius: 8px;
        overflow: hidden;
      }

      .meter-fill {
        height: 100%;
        transition: width 0.35s ease;
      }

      .hp-fill {
        background: var(--hp);
      }

      .mp-fill {
        background: var(--mp);
      }

      .status-tag {
        display: inline-block;
        background: rgba(255, 255, 255, 0.07);
        padding: 4px 8px;
        border-radius: 9px;
        border: 1px solid var(--line);
        color: var(--muted);
        margin-top: 6px;
        font-size: 0.8rem;
      }

      .middle-layer {
        position: relative;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding: 0 16px;
        min-height: 200px;
      }

      .log-panel {
        position: absolute;
        top: 6px;
        left: 14px;
        width: 250px;
        max-height: 160px;
        background: var(--panel);
        border-radius: 14px;
        border: 1px solid var(--line);
        padding: 8px;
        box-shadow: var(--shadow);
        display: flex;
        flex-direction: column;
      }

      .log-panel h3 {
        color: var(--secondary);
        margin-bottom: 6px;
      }

      .log-body {
        flex: 1;
        overflow: hidden;
        display: flex;
        flex-direction: column-reverse;
        gap: 5px;
        max-height: 118px;
      }

      .log-line {
        background: rgba(255, 255, 255, 0.04);
        padding: 7px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.05);
        color: var(--text);
      }

      .arena-center {
        display: flex;
        align-items: flex-start;
        justify-content: center;
        width: 100%;
        padding-top: 2px;
      }

      .hero-row {
        position: relative;
        display: flex;
        justify-content: center;
        gap: 10px;
        padding: 8px 14px 0;
        flex-wrap: wrap;
      }

      .hero-card {
        width: 195px;
        background: var(--card);
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        padding: 8px;
        box-shadow: var(--shadow);
        transition: transform 0.3s ease, box-shadow 0.3s ease,
          border-color 0.3s ease;
      }

      .hero-card.active {
        transform: translateY(-8px) scale(1.015);
        border-color: var(--primary);
        box-shadow: 0 20px 40px rgba(116, 240, 237, 0.28);
      }

      .hero-top {
        display: flex;
        gap: 7px;
        align-items: center;
      }

      .hero-avatar {
        width: 54px;
        height: 54px;
        border-radius: 10px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: #0c142f;
      }

      .hero-avatar img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      .hero-name {
        font-size: 1rem;
      }

      .hero-role {
        color: var(--muted);
        font-size: 0.82rem;
      }

      .stat-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 4px;
        margin-top: 6px;
      }

      .stat-chip {
        text-align: center;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 7px;
        padding: 4px 3px;
        color: var(--muted);
        font-size: 0.8rem;
      }

      .stat-chip strong {
        display: block;
        color: var(--text);
      }

      .skill-bar {
        margin: 6px auto 0;
        width: clamp(700px, 68vw, 860px);
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 7px 9px;
        box-shadow: var(--shadow);
        display: flex;
        flex-direction: column;
        gap: 7px;
        position: relative;
      }

      .skill-buttons {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 7px;
      }

      .skill-button {
        background: linear-gradient(
          135deg,
          rgba(116, 240, 237, 0.2),
          rgba(116, 240, 237, 0.1)
        );
        border: 1px solid rgba(116, 240, 237, 0.4);
        border-radius: 10px;
        padding: 8px;
        color: var(--text);
        cursor: pointer;
        text-align: left;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        font-size: 0.9rem;
      }

      .skill-button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 10px 18px rgba(116, 240, 237, 0.25);
      }

      .skill-button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .skill-meta {
        display: flex;
        justify-content: space-between;
        color: var(--muted);
        font-size: 0.85rem;
      }

      .skill-info {
        background: var(--panel);
        border: 1px solid var(--line);
        border-radius: 11px;
        padding: 8px 10px;
        color: var(--text);
        box-shadow: var(--shadow);
        position: absolute;
        display: none;
        pointer-events: none;
        transform: translate(-50%, calc(-100% - 8px));
        max-width: 220px;
        z-index: 5;
      }

      .skill-info h4 {
        color: var(--secondary);
        margin-bottom: 6px;
      }

      .target-layer {
        position: fixed;
        inset: 0;
        background: rgba(5, 9, 18, 0.7);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 150;
      }

      .target-window {
        background: var(--card);
        padding: 18px;
        border-radius: 14px;
        border: 1px solid var(--line);
        box-shadow: var(--shadow);
        width: min(440px, 92vw);
      }

      .target-window h3 {
        color: var(--secondary);
        margin-bottom: 10px;
      }

      .target-options {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .target-btn {
        flex: 1 1 45%;
        padding: 10px 9px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        color: var(--text);
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .target-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 20px rgba(0, 0, 0, 0.35);
      }

      .target-actions {
        margin-top: 12px;
        display: flex;
        justify-content: flex-end;
      }

      .target-cancel {
        padding: 8px 14px;
        background: rgba(255, 107, 107, 0.12);
        border: 1px solid rgba(255, 107, 107, 0.35);
        color: var(--text);
        border-radius: 10px;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.2s ease;
      }

      .target-cancel:hover {
        background: rgba(255, 107, 107, 0.18);
        transform: translateY(-1px);
      }

      .target-highlight {
        box-shadow: 0 0 0 2px var(--secondary), 0 14px 30px rgba(116, 240, 237, 0.25);
        transform: translateY(-2px);
      }

      .footer-row {
        position: relative;
        z-index: 3;
        padding: 0 12px 12px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
      }

      .waiting-text {
        color: var(--muted);
        text-align: center;
      }

      .game-over {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.82);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 190;
      }

      .game-over-card {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 18px;
        padding: 28px;
        text-align: center;
        box-shadow: var(--shadow);
        width: min(480px, 92vw);
      }

      .victory {
        color: var(--primary);
      }
      .defeat {
        color: var(--accent);
      }

      .restart {
        margin-top: 16px;
        padding: 10px 20px;
        border: none;
        border-radius: 12px;
        background: linear-gradient(
          135deg,
          rgba(255, 200, 87, 0.9),
          rgba(255, 200, 87, 0.6)
        );
        color: #261402;
        font-weight: 700;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div class="game-shell">
      <div class="start-screen" id="startScreen">
        <div class="start-panel">
          <h1>Celestia Clash</h1>
          <p>
            Turn-based RPG demo. Command your squad and break the dragon's fury.
          </p>
          <button class="start-button" id="startButton">Start</button>
        </div>
      </div>

      <div class="battle-field" id="battleField" style="display: none">
        <div class="nebula"></div>
        <div class="battle-layer">
          <div class="turn-order">
            <div class="turn-track">
              <div class="turn-line"></div>
              <div class="turn-nodes" id="turnNodes"></div>
            </div>
          </div>

          <div class="middle-layer">
            <div class="log-panel">
              <h3 style="text-align: center">Battle Log</h3>
              <div class="log-body" id="logBody"></div>
            </div>
            <div class="arena-center">
              <div class="dragon-area">
                <div class="boss-card" id="bossCard">
                  <div class="boss-top">
                    <div class="boss-avatar">
                      <img src="gif/dragon.gif" alt="Dragon" />
                    </div>
                    <div class="boss-meta">
                      <h2>Obsidian Dragon</h2>
                      <div class="meter">
                        <div class="meter-label">
                          <span>HP</span>
                          <span id="bossHpText">--</span>
                        </div>
                        <div class="meter-bar">
                          <div class="meter-fill hp-fill" id="bossHpBar"></div>
                        </div>
                      </div>
                      <div class="meter">
                        <div class="meter-label">
                          <span>MP</span>
                          <span id="bossMpText">--</span>
                        </div>
                        <div class="meter-bar">
                          <div class="meter-fill mp-fill" id="bossMpBar"></div>
                        </div>
                      </div>
                      <div
                        class="status-tag"
                        id="bossStatus"
                        style="display: none"
                      ></div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="footer-row">
            <div class="hero-row" id="heroRow"></div>
            <div class="skill-bar" id="skillBar">
              <div class="skill-buttons" id="skillButtons"></div>
              <div
                class="skill-info"
                id="skillInfo"
                style="display: none"
              ></div>
              <div class="waiting-text" id="waitingText">Waiting...</div>
            </div>
          </div>
        </div>
      </div>

      <div class="target-layer" id="targetLayer">
        <div class="target-window">
          <h3>Select a target</h3>
          <div class="target-options" id="targetOptions"></div>
          <div class="target-actions">
            <button class="target-cancel" id="targetCancel">✕ Cancel</button>
          </div>
        </div>
      </div>

      <div class="game-over" id="gameOver">
        <div class="game-over-card">
          <h2 id="gameOverTitle" class="victory">Victory</h2>
          <p id="gameOverText">Your team stands triumphant!</p>
          <button class="restart" id="restart">Restart</button>
        </div>
      </div>
    </div>

    <script>
      const heroConfigs = [
        {
          id: "soldier",
          name: "Soldier",
          role: "Physical DPS",
          maxHp: 150,
          maxMp: 60,
          atk: 34,
          def: 14,
          mag: 6,
          skills: [
            {
              id: "basicSlash",
              name: "Basic Attack",
              cost: 0,
              target: "enemy",
              type: "physical",
              power: 0.9,
              description: "Reliable strike when MP is low.",
            },
            {
              id: "powerSlash",
              name: "Power Slash",
              cost: 14,
              target: "enemy",
              type: "physical",
              power: 1.4,
              description: "Heavy physical blow dealing strong damage.",
            },
            {
              id: "armorBreak",
              name: "Armor Break",
              cost: 16,
              target: "enemy",
              type: "physical",
              power: 1.1,
              debuff: { defDown: 0.2, duration: 2 },
              description:
                "Strike that reduces the dragon's defense for 2 turns.",
            },
            {
              id: "rally",
              name: "Rally",
              cost: 10,
              target: "allies",
              type: "buff",
              buff: { atkUp: 0.2, duration: 2 },
              description: "Encourage allies, boosting attack for 2 turns.",
            },
          ],
        },
        {
          id: "mage",
          name: "Mage",
          role: "Magic DPS",
          maxHp: 110,
          maxMp: 120,
          atk: 10,
          def: 10,
          mag: 40,
          skills: [
            {
              id: "arcaneBolt",
              name: "Arcane Bolt",
              cost: 12,
              target: "enemy",
              type: "magic",
              power: 1.3,
              description: "Precise arcane shot of pure energy.",
            },
            {
              id: "firestorm",
              name: "Firestorm",
              cost: 22,
              target: "all-enemies",
              type: "magic",
              power: 1.1,
              description:
                "AoE inferno that scorches the dragon and leaves burning embers.",
              dot: { amount: 6, duration: 2 },
            },
            {
              id: "manaSurge",
              name: "Mana Surge",
              cost: 18,
              target: "self",
              type: "buff",
              buff: { magUp: 0.3, duration: 2 },
              description: "Channel energy to boost magic for 2 turns.",
            },
            {
              id: "weakSpark",
              name: "Weak Spark",
              cost: 6,
              target: "enemy",
              type: "magic",
              power: 0.8,
              description: "Low-cost spark to conserve mana.",
            },
          ],
        },
        {
          id: "healer",
          name: "Healer",
          role: "Support",
          maxHp: 140,
          maxMp: 90,
          atk: 12,
          def: 16,
          mag: 24,
          skills: [
            {
              id: "singleHeal",
              name: "Single Heal",
              cost: 14,
              target: "ally",
              type: "heal",
              power: 0.45,
              description: "Restore a large amount of HP to one ally.",
            },
            {
              id: "groupHeal",
              name: "Group Heal",
              cost: 18,
              target: "allies",
              type: "heal",
              power: 0.25,
              description: "Restore moderate HP to all allies.",
            },
            {
              id: "cleanse",
              name: "Cleanse",
              cost: 12,
              target: "ally",
              type: "cleanse",
              description: "Remove harmful debuffs from one ally.",
            },
            {
              id: "lightStrike",
              name: "Light Strike",
              cost: 4,
              target: "enemy",
              type: "magic",
              power: 0.6,
              description: "Gentle strike of light magic.",
            },
          ],
        },
        {
          id: "tank",
          name: "Tank",
          role: "Defender",
          maxHp: 220,
          maxMp: 60,
          atk: 18,
          def: 28,
          mag: 8,
          skills: [
            {
              id: "bash",
              name: "Bash",
              cost: 8,
              target: "enemy",
              type: "physical",
              power: 1.0,
              description: "Shield bash with chance to shake the dragon.",
              debuff: { dmgDown: 0.15, duration: 1 },
            },
            {
              id: "guard",
              name: "Guard",
              cost: 10,
              target: "self",
              type: "buff",
              buff: { guard: 0.4, duration: 1 },
              description:
                "Brace for impact, cutting incoming damage this turn.",
            },
            {
              id: "taunt",
              name: "Provoke",
              cost: 12,
              target: "self",
              type: "taunt",
              duration: 2,
              description: "Draw the dragon's focus for 2 turns.",
            },
            {
              id: "shieldWall",
              name: "Shield Wall",
              cost: 16,
              target: "allies",
              type: "buff",
              buff: { guardTeam: 0.2, duration: 2 },
              description:
                "Raise shields for the whole squad, reducing damage for 2 turns.",
            },
          ],
        },
      ];

      const bossConfig = {
        id: "boss",
        name: "Obsidian Dragon",
        maxHp: 2200,
        maxMp: 200,
        atk: 42,
        def: 24,
        mag: 36,
        status: {},
        skills: [
          {
            id: "crushingBlow",
            cost: 0,
            type: "physical",
            power: 1.15,
            target: "enemy",
            weight: 4,
          },
          {
            id: "fieryOnslaught",
            cost: 24,
            type: "magic",
            power: 1.85,
            splashPower: 0.75,
            target: "enemy",
            weight: 3,
          },
          {
            id: "searingRoar",
            cost: 18,
            type: "magic",
            power: 1.15,
            target: "all-enemies",
            weight: 3,
          },
          {
            id: "apexPredation",
            cost: 36,
            type: "physical",
            power: 2.35,
            target: "enemy",
            weight: 1,
          },
        ],
      };

      class Game {
        constructor() {
          this.heroes = heroConfigs.map((h) => ({
            ...h,
            hp: h.maxHp,
            mp: h.maxMp,
            status: {},
          }));
          this.boss = {
            ...bossConfig,
            hp: bossConfig.maxHp,
            mp: bossConfig.maxMp,
          };
          this.bossEnraged = false;
          this.turnOrder = ["soldier", "mage", "healer", "tank", "boss"];
          this.turnIndex = 0;
          this.state = "menu";
          this.pendingSkill = null;
          this.logEl = document.getElementById("logBody");
          this.heroRow = document.getElementById("heroRow");
          this.skillButtons = document.getElementById("skillButtons");
          this.skillBar = document.getElementById("skillBar");
          this.skillInfo = document.getElementById("skillInfo");
          this.waitingText = document.getElementById("waitingText");
          this.turnNodes = document.getElementById("turnNodes");
          this.targetLayer = document.getElementById("targetLayer");
          this.targetOptions = document.getElementById("targetOptions");
          this.targetCancel = document.getElementById("targetCancel");
          this.targetingActive = false;
          this.bindMenu();
          this.renderHeroes();
          this.updateUI();
        }

        bindMenu() {
          document
            .getElementById("startButton")
            .addEventListener("click", () => {
              document.getElementById("startScreen").style.display = "none";
              document.getElementById("battleField").style.display = "block";
              this.state = "playing";
              this.startTurn();
            });

          document.getElementById("restart").addEventListener("click", () => {
            this.reset();
          });

          this.targetCancel.addEventListener("click", () => {
            this.cancelTargeting();
          });
        }

        reset() {
          this.heroes = heroConfigs.map((h) => ({
            ...h,
            hp: h.maxHp,
            mp: h.maxMp,
            status: {},
          }));
          this.boss = {
            ...bossConfig,
            hp: bossConfig.maxHp,
            mp: bossConfig.maxMp,
            status: {},
          };
          this.turnIndex = 0;
          this.state = "playing";
          this.pendingSkill = null;
          this.targetingActive = false;
          this.bossEnraged = false;
          this.closeTargetSelect();
          document.getElementById("gameOver").style.display = "none";
          this.logEl.innerHTML = "";
          this.renderHeroes();
          this.updateUI();
          this.startTurn();
        }

        renderHeroes() {
          this.heroRow.innerHTML = "";
          this.heroes.forEach((hero) => {
            const card = document.createElement("div");
            card.className = "hero-card";
            card.id = `${hero.id}Card`;
            card.innerHTML = `
              <div class="hero-top">
                <div class="hero-avatar"><img src="gif/${hero.id}.gif" alt="${hero.name}" /></div>
                <div>
                  <div class="hero-name">${hero.name}</div>
                  <div class="hero-role">${hero.role}</div>
                  <div class="status-tag" id="${hero.id}Status" style="display:none"></div>
                </div>
              </div>
              <div class="meter" style="margin-top:10px;">
                <div class="meter-label"><span>HP</span><span id="${hero.id}HpText"></span></div>
                <div class="meter-bar"><div class="meter-fill hp-fill" id="${hero.id}HpBar"></div></div>
              </div>
              <div class="meter" style="margin-top:8px;">
                <div class="meter-label"><span>MP</span><span id="${hero.id}MpText"></span></div>
                <div class="meter-bar"><div class="meter-fill mp-fill" id="${hero.id}MpBar"></div></div>
              </div>
              <div class="stat-grid">
                <div class="stat-chip">ATK<strong>${hero.atk}</strong></div>
                <div class="stat-chip">DEF<strong>${hero.def}</strong></div>
                <div class="stat-chip">MAG<strong>${hero.mag}</strong></div>
              </div>
            `;
            this.heroRow.appendChild(card);
          });
        }

        log(message) {
          const entry = document.createElement("div");
          entry.className = "log-line";
          entry.textContent = message;
          this.logEl.prepend(entry);
          const maxEntries = 6;
          while (this.logEl.children.length > maxEntries) {
            this.logEl.removeChild(this.logEl.lastElementChild);
          }
        }

        getHero(id) {
          return this.heroes.find((h) => h.id === id);
        }

        startTurn() {
          if (this.state !== "playing") return;
          this.applyDurations();
          const current = this.turnOrder[this.turnIndex];
          this.highlightTurn();
          if (current === "boss") {
            this.waitingText.textContent = "Dragon is acting...";
            this.skillButtons.innerHTML = "";
            this.skillInfo.style.display = "none";
            setTimeout(() => this.dragonAct(), 700);
          } else {
            const hero = this.getHero(current);
            if (hero.hp <= 0) {
              this.advanceTurn();
              return;
            }
            this.waitingText.textContent = `${hero.name}'s turn`;
            this.renderSkillBar(hero);
          }
        }

        highlightTurn() {
          this.heroes.forEach((hero) => {
            const card = document.getElementById(`${hero.id}Card`);
            if (this.turnOrder[this.turnIndex] === hero.id && hero.hp > 0) {
              card.classList.add("active");
            } else {
              card.classList.remove("active");
            }
          });
          this.renderTurnNodes();
        }

        renderTurnNodes() {
          this.turnNodes.innerHTML = "";
          for (let i = 0; i < this.turnOrder.length; i++) {
            const idx = (this.turnIndex + i) % this.turnOrder.length;
            const id = this.turnOrder[idx];
            const node = document.createElement("div");
            node.className = "turn-node" + (i === 0 ? " active" : "");
            const img = document.createElement("img");
            const src = id === "boss" ? "gif/dragon.gif" : `gif/${id}.gif`;
            img.src = src;
            img.alt = id;
            node.appendChild(img);
            this.turnNodes.appendChild(node);
          }
        }

        renderSkillBar(hero) {
          this.skillButtons.innerHTML = "";
          this.skillInfo.style.display = "none";
          hero.skills.forEach((skill) => {
            const btn = document.createElement("button");
            btn.className = "skill-button";
            btn.innerHTML = `<div><strong>${skill.name}</strong></div>
              <div class="skill-meta"><span>${skill.target}</span><span>MP ${skill.cost}</span></div>`;
            btn.disabled = hero.mp < skill.cost || hero.hp <= 0;
            btn.addEventListener("click", () => {
              this.pendingSkill = { hero, skill };
              this.prepareTargeting(hero, skill);
            });
            btn.addEventListener("mouseenter", () => {
              this.showSkillInfo(skill, btn);
            });
            btn.addEventListener("mouseleave", () => {
              this.hideSkillInfo();
            });
            this.skillButtons.appendChild(btn);
          });
        }

        showSkillInfo(skill, anchor) {
          this.skillInfo.style.display = "block";
          const targetLabel =
            skill.target === "enemy"
              ? "Single Target"
              : skill.target === "all-enemies"
              ? "AoE Enemy"
              : skill.target === "ally"
              ? "Ally"
              : skill.target === "allies"
              ? "All Allies"
              : "Self";
          this.skillInfo.innerHTML = `
            <h4>${skill.name}</h4>
            <div style="color:var(--muted);margin-bottom:6px;">${targetLabel} · MP ${skill.cost}</div>
            <p>${skill.description}</p>
          `;
          const containerRect = this.skillBar.getBoundingClientRect();
          const buttonRect = anchor.getBoundingClientRect();
          const left = buttonRect.left - containerRect.left + buttonRect.width / 2;
          const top = buttonRect.top - containerRect.top;
          this.skillInfo.style.left = `${left}px`;
          this.skillInfo.style.top = `${top}px`;
        }

        hideSkillInfo() {
          this.skillInfo.style.display = "none";
        }

        prepareTargeting(hero, skill) {
          if (["self", "allies", "all-enemies"].includes(skill.target)) {
            this.executeSkill(hero, skill);
          } else if (skill.target === "enemy") {
            this.executeSkill(hero, skill, this.boss);
          } else {
            this.openTargetSelect(
              skill.target === "ally"
                ? this.heroes.filter((h) => h.hp > 0)
                : [this.boss],
              (target) => {
                this.executeSkill(hero, skill, target);
              }
            );
          }
        }

        openTargetSelect(options, callback) {
          this.targetingActive = true;
          this.targetOptions.innerHTML = "";
          this.highlightTargets(options);
          options.forEach((t) => {
            const btn = document.createElement("button");
            btn.className = "target-btn";
            btn.textContent = t.name;
            btn.addEventListener("click", () => {
              this.closeTargetSelect();
              callback(t);
            });
            this.targetOptions.appendChild(btn);
          });
          this.targetLayer.style.display = "flex";
        }

        closeTargetSelect() {
          this.targetLayer.style.display = "none";
          this.targetOptions.innerHTML = "";
          this.clearTargetHighlights();
          this.targetingActive = false;
        }

        cancelTargeting() {
          if (!this.targetingActive) return;
          this.pendingSkill = null;
          this.closeTargetSelect();
        }

        highlightTargets(options) {
          this.clearTargetHighlights();
          options.forEach((t) => {
            const el = document.getElementById(
              t.id === "boss" ? "bossCard" : `${t.id}Card`
            );
            if (el) el.classList.add("target-highlight");
          });
        }

        clearTargetHighlights() {
          document
            .querySelectorAll(".target-highlight")
            .forEach((el) => el.classList.remove("target-highlight"));
        }

        applyDurations() {
          const decay = (status) => {
            Object.keys(status).forEach((k) => {
              if (status[k] && typeof status[k].duration === "number") {
                status[k].duration -= 1;
                if (status[k].duration <= 0) delete status[k];
              }
            });
          };
          this.heroes.forEach((h) => decay(h.status));
          decay(this.boss.status || {});
        }

        computeDefense(target) {
          let modifier = 1;
          if (target.status.defDown) modifier += target.status.defDown.amount;
          return Math.max(0.1, (target.def || this.boss.def) * modifier);
        }

        applyDamage(source, target, skill, powerOverride = null) {
          const isMagic = skill.type === "magic";
          const attackStat = isMagic ? source.mag : source.atk;
          const defense = target.id === "boss" ? this.boss.def : target.def;
          let base = Math.max(0, attackStat - defense * 0.5);
          const power = powerOverride ?? skill.power || 1;
          let buffMulti = 1;
          if (source.status.atkUp && !isMagic)
            buffMulti += source.status.atkUp.amount;
          if (source.status.magUp && isMagic)
            buffMulti += source.status.magUp.amount;
          if (target.status.dmgDown) buffMulti -= target.status.dmgDown.amount;
          const guardCut = target.status.guard?.amount || 0;
          const guardTeam = target.status.guardTeam?.amount || 0;
          const enraged = this.boss.hp <= this.boss.maxHp * 0.5 || this.bossEnraged;
          let damage = Math.max(
            8,
            Math.round(base * power * buffMulti * (1 - guardCut - guardTeam))
          );
          if (source.id === "boss" && enraged) {
            damage = Math.max(8, Math.round(damage * 2));
            this.bossEnraged = true;
          }
          target.hp = Math.max(0, target.hp - damage);
          if (
            target.id === "boss" &&
            !this.bossEnraged &&
            target.hp <= target.maxHp * 0.5
          ) {
            this.bossEnraged = true;
            this.log(`${this.boss.name} becomes enraged! Its attacks intensify.`);
          }
          if (skill.debuff) {
            target.status = target.status || {};
            Object.keys(skill.debuff).forEach((key) => {
              if (key !== "duration") {
                target.status[key] = {
                  amount: skill.debuff[key],
                  duration: skill.debuff.duration,
                };
              }
            });
          }
          if (skill.dot) {
            target.status = target.status || {};
            target.status.dot = {
              amount: skill.dot.amount,
              duration: skill.dot.duration,
            };
          }
          return damage;
        }

        applyHeal(source, target, skill) {
          const power = skill.power || 0.3;
          const amount = Math.round(source.mag * 2 * power);
          target.hp = Math.min(target.maxHp, target.hp + amount);
          return amount;
        }

        executeSkill(user, skill, target = null) {
          this.pendingSkill = null;
          if (user.mp < skill.cost) return;
          user.mp -= skill.cost;
          if (!target) target = skill.target === "self" ? user : null;

          if (skill.type === "physical" || skill.type === "magic") {
            const tgt = target || this.boss;
            const dmg = this.applyDamage(user, tgt, skill);
            const name = tgt.id === "boss" ? this.boss.name : tgt.name;
            this.log(
              `${user.name} used ${skill.name} on ${name} for ${dmg} damage.`
            );
            if (skill.execute && tgt.hp / tgt.maxHp < skill.execute) {
              tgt.hp = Math.max(0, tgt.hp - 40);
              this.log(`${skill.name} bites harder against weakened foes!`);
            }
          } else if (skill.type === "heal") {
            if (skill.target === "allies") {
              this.heroes.forEach((h) => {
                if (h.hp > 0) {
                  const healed = this.applyHeal(user, h, skill);
                  this.log(`${user.name} heals ${h.name} for ${healed}.`);
                }
              });
            } else if (target) {
              const healed = this.applyHeal(user, target, skill);
              this.log(`${user.name} heals ${target.name} for ${healed}.`);
            }
          } else if (skill.type === "buff") {
            const applyBuff = (t) => {
              t.status = t.status || {};
              Object.keys(skill.buff).forEach((key) => {
                if (key !== "duration") {
                  t.status[key] = {
                    amount: skill.buff[key],
                    duration: skill.buff.duration,
                  };
                }
              });
            };
            if (skill.target === "allies") this.heroes.forEach(applyBuff);
            else applyBuff(target || user);
            this.log(`${user.name} uses ${skill.name} to empower allies.`);
          } else if (skill.type === "cleanse" && target) {
            target.status = {};
            this.log(`${user.name} cleansed ${target.name}.`);
          } else if (skill.type === "taunt") {
            this.boss.status.taunt = {
              amount: 1,
              duration: skill.duration,
              target: user.id,
            };
            this.log(`${user.name} provokes the dragon!`);
          }

          this.resolveDot();
          this.updateUI();
          this.checkEnd();
          if (this.state === "playing") {
            this.advanceTurn();
          }
        }

        resolveDot() {
          if (this.boss.status.dot) {
            const dot = this.boss.status.dot;
            this.boss.hp = Math.max(0, this.boss.hp - dot.amount);
            this.log(`Burning embers scorch the dragon for ${dot.amount}.`);
            if (!this.bossEnraged && this.boss.hp <= this.boss.maxHp * 0.5) {
              this.bossEnraged = true;
              this.log(`${this.boss.name} becomes enraged! Its attacks intensify.`);
            }
          }
        }

        weightedChoice(skills) {
          const total = skills.reduce((sum, skill) => sum + (skill.weight || 1), 0);
          let roll = Math.random() * total;
          for (const skill of skills) {
            roll -= skill.weight || 1;
            if (roll <= 0) return skill;
          }
          return skills[0];
        }

        pickPriorityTarget(aliveHeroes) {
          const tauntTarget = this.boss.status.taunt?.target;
          const weighted = aliveHeroes.map((hero) => {
            const hpRatio = hero.hp / hero.maxHp;
            let weight = 1 - hpRatio + 0.1;
            if (tauntTarget === hero.id) weight += 0.8;
            return { hero, weight };
          });
          const total = weighted.reduce((sum, w) => sum + w.weight, 0);
          let roll = Math.random() * total;
          for (const entry of weighted) {
            roll -= entry.weight;
            if (roll <= 0) return entry.hero;
          }
          return aliveHeroes[0];
        }

        dragonAct() {
          const boss = this.boss;
          const aliveHeroes = this.heroes.filter((h) => h.hp > 0);
          if (!aliveHeroes.length) {
            this.checkEnd();
            return;
          }

          if (
            boss.status.taunt &&
            (!this.getHero(boss.status.taunt.target) ||
              this.getHero(boss.status.taunt.target).hp <= 0)
          ) {
            delete boss.status.taunt;
          }

          const affordable = boss.skills.filter(
            (s) => s.cost === 0 || s.cost <= boss.mp
          );
          const pool = affordable.length ? affordable : [boss.skills[0]];
          const choice = this.weightedChoice(pool);

          boss.mp = Math.max(0, boss.mp - choice.cost);

          if (
            boss.status.taunt &&
            this.getHero(boss.status.taunt.target)?.hp > 0
          ) {
            this.log(
              `Dragon is provoked and eyes ${
                this.getHero(boss.status.taunt.target).name
              }!`
            );
          }

          if (choice.target === "all-enemies") {
            this.heroes.forEach((hero) => {
              if (hero.hp > 0) {
                const dmg = this.applyDamage(boss, hero, choice);
                this.log(`Dragon scorched ${hero.name} for ${dmg} damage.`);
              }
            });
          } else if (choice.id === "fieryOnslaught") {
            const targetHero = this.pickPriorityTarget(aliveHeroes);
            const mainDmg = this.applyDamage(
              boss,
              targetHero,
              choice,
              choice.power
            );
            this.log(
              `Dragon unleashed a fiery blast on ${targetHero.name} for ${mainDmg} damage.`
            );
            aliveHeroes
              .filter((h) => h.id !== targetHero.id)
              .forEach((hero) => {
                const splashDmg = this.applyDamage(
                  boss,
                  hero,
                  choice,
                  choice.splashPower
                );
                this.log(
                  `Splashing flames seared ${hero.name} for ${splashDmg} damage.`
                );
              });
          } else {
            const targetHero = this.pickPriorityTarget(aliveHeroes);
            const dmg = this.applyDamage(boss, targetHero, choice);
            if (choice.id === "apexPredation") {
              this.log(
                `Dragon used a devastating attack on ${targetHero.name} for ${dmg} damage.`
              );
            } else {
              this.log(
                `Dragon attacked ${targetHero.name} with a basic strike for ${dmg} damage.`
              );
            }
          }

          this.resolveDot();
          this.updateUI();
          this.checkEnd();
          if (this.state === "playing") this.advanceTurn();
        }

        advanceTurn() {
          this.turnIndex = (this.turnIndex + 1) % this.turnOrder.length;
          setTimeout(() => this.startTurn(), 600);
        }

        updateUI() {
          const bossHpPct = (this.boss.hp / this.boss.maxHp) * 100;
          const bossMpPct = (this.boss.mp / this.boss.maxMp) * 100;
          document.getElementById("bossHpBar").style.width = `${bossHpPct}%`;
          document.getElementById("bossMpBar").style.width = `${bossMpPct}%`;
          document.getElementById(
            "bossHpText"
          ).textContent = `${this.boss.hp}/${this.boss.maxHp}`;
          document.getElementById(
            "bossMpText"
          ).textContent = `${this.boss.mp}/${this.boss.maxMp}`;
          const bossStatus = document.getElementById("bossStatus");
          bossStatus.style.display =
            this.boss.status && Object.keys(this.boss.status).length
              ? "inline-block"
              : "none";
          bossStatus.textContent =
            this.boss.status && this.boss.status.dot ? "Burning" : "";

          this.heroes.forEach((h) => {
            const hpPct = (h.hp / h.maxHp) * 100;
            const mpPct = (h.mp / h.maxMp) * 100;
            document.getElementById(`${h.id}HpBar`).style.width = `${hpPct}%`;
            document.getElementById(`${h.id}MpBar`).style.width = `${mpPct}%`;
            document.getElementById(
              `${h.id}HpText`
            ).textContent = `${h.hp}/${h.maxHp}`;
            document.getElementById(
              `${h.id}MpText`
            ).textContent = `${h.mp}/${h.maxMp}`;
            const status = document.getElementById(`${h.id}Status`);
            const labels = [];
            if (h.status.atkUp) labels.push("ATK↑");
            if (h.status.magUp) labels.push("MAG↑");
            if (h.status.guard) labels.push("Guard");
            if (h.status.guardTeam) labels.push("Shielded");
            if (h.status.atkDown) labels.push("ATK↓");
            status.textContent = labels.join(" · ");
            status.style.display = labels.length ? "inline-block" : "none";
          });
        }

        checkEnd() {
          const heroesAlive = this.heroes.some((h) => h.hp > 0);
          if (this.boss.hp <= 0) {
            this.state = "victory";
            document.getElementById("gameOver").style.display = "flex";
            document.getElementById("gameOverTitle").textContent = "Victory";
            document.getElementById("gameOverTitle").className = "victory";
            document.getElementById("gameOverText").textContent =
              "The dragon collapses under your tactics.";
          } else if (!heroesAlive) {
            this.state = "defeat";
            document.getElementById("gameOver").style.display = "flex";
            document.getElementById("gameOverTitle").textContent = "Defeat";
            document.getElementById("gameOverTitle").className = "defeat";
            document.getElementById("gameOverText").textContent =
              "Your party falls to the dragon's rage.";
          }
        }
      }

      new Game();
    </script>
  </body>
</html>
