<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Celestia Clash - Turn Battle</title>
    <style>
      @font-face {
        font-family: "Monocraft";
        src: url("fonts/Monocraft.otf") format("opentype"),
          url("fonts/Monocraft.ttf") format("truetype");
      }

      :root {
        --space: #050912;
        --panel: rgba(18, 26, 48, 0.8);
        --card: rgba(23, 32, 60, 0.9);
        --line: rgba(116, 240, 237, 0.3);
        --hp: linear-gradient(90deg, #ff8f70, #ff3d3d);
        --mp: linear-gradient(90deg, #74b9ff, #0984e3);
        --accent: #ff6b6b;
        --primary: #74f0ed;
        --secondary: #ffc857;
        --text: #e3ecff;
        --muted: #9eb0d3;
        --shadow: 0 20px 45px rgba(5, 9, 18, 0.55);
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Monocraft", monospace;
        font-size: 15px;
        background: radial-gradient(
            circle at 20% 20%,
            rgba(116, 240, 237, 0.14),
            transparent 28%
          ),
          radial-gradient(
            circle at 80% 15%,
            rgba(255, 200, 87, 0.12),
            transparent 32%
          ),
          radial-gradient(
            circle at 35% 70%,
            rgba(255, 107, 107, 0.12),
            transparent 26%
          ),
          linear-gradient(180deg, #070b18, #050912 55%, #05060f);
        color: var(--text);
        min-height: 100vh;
        overflow-x: hidden;
      }

      .game-shell {
        position: relative;
        min-height: 100vh;
        width: 100%;
        display: flex;
        flex-direction: column;
      }

      .start-screen {
        position: fixed;
        inset: 0;
        background: radial-gradient(
            circle at 50% 30%,
            rgba(116, 240, 237, 0.25),
            transparent 40%
          ),
          radial-gradient(
            circle at 70% 70%,
            rgba(255, 107, 107, 0.2),
            transparent 45%
          ),
          rgba(5, 9, 18, 0.92);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 200;
      }

      .start-panel {
        background: var(--card);
        padding: 28px 36px;
        border-radius: 16px;
        border: 1px solid var(--line);
        box-shadow: var(--shadow);
        text-align: center;
        width: min(420px, 88vw);
      }

      .start-panel h1 {
        font-size: 2.2rem;
        color: var(--primary);
        text-shadow: 0 10px 26px rgba(116, 240, 237, 0.35);
      }

      .start-panel p {
        margin: 8px 0 16px;
        color: var(--muted);
      }

      .start-button {
        padding: 10px 22px;
        background: linear-gradient(
          135deg,
          rgba(116, 240, 237, 0.9),
          rgba(116, 240, 237, 0.65)
        );
        color: #03101c;
        border: none;
        border-radius: 12px;
        font-weight: 700;
        font-size: 1rem;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 0 12px 22px rgba(116, 240, 237, 0.35);
      }

      .start-button:hover {
        transform: translateY(-2px);
      }

      .battle-field {
        flex: 1;
        position: relative;
        overflow-x: hidden;
        overflow-y: auto;
      }

      .nebula {
        position: absolute;
        inset: 0;
        background: radial-gradient(
            circle at 50% 10%,
            rgba(116, 240, 237, 0.12),
            transparent 40%
          ),
          radial-gradient(
            circle at 52% 80%,
            rgba(255, 107, 107, 0.12),
            transparent 35%
          ),
          radial-gradient(
            circle at 20% 50%,
            rgba(255, 200, 87, 0.12),
            transparent 45%
          );
        filter: blur(20px);
        z-index: 1;
      }

      .battle-layer {
        position: relative;
        z-index: 2;
        width: 100%;
        min-height: 92vh;
        display: grid;
        grid-template-rows: auto 1fr auto;
        gap: 10px;
        padding: 4px 0 12px;
      }

      .turn-order {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        padding-top: 12px;
      }

      .turn-track {
        position: relative;
        width: 520px;
        max-width: 78vw;
        height: 66px;
      }

      .turn-line {
        position: absolute;
        inset: 50% 0 0 0;
        height: 2px;
        background: var(--line);
      }

      .turn-nodes {
        position: absolute;
        inset: 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .turn-node {
        width: 58px;
        height: 58px;
        border-radius: 50%;
        border: 2px solid var(--line);
        background: rgba(255, 255, 255, 0.05);
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        box-shadow: 0 12px 22px rgba(0, 0, 0, 0.35);
        transition: transform 0.25s ease, border-color 0.25s ease,
          box-shadow 0.25s ease;
      }

      .turn-node.active {
        transform: scale(1.08) translateY(-6px);
        border-color: var(--primary);
        box-shadow: 0 16px 28px rgba(116, 240, 237, 0.25);
      }

      .turn-node img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .dragon-area {
        position: relative;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding-top: 8px;
        width: min(500px, 100%);
      }

      .boss-card {
        margin: 0 auto;
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 16px;
        width: 340px;
        max-width: 100%;
        padding: 14px;
        box-shadow: var(--shadow);
      }

      .boss-top {
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .boss-avatar {
        width: 100px;
        height: 100px;
        border-radius: 14px;
        overflow: hidden;
        background: #0c142f;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .boss-avatar img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      .boss-meta h2 {
        color: var(--secondary);
        letter-spacing: 1px;
        font-size: 1.25rem;
      }

      .meter {
        margin-top: 8px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        padding: 7px;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .meter-label {
        display: flex;
        justify-content: space-between;
        color: var(--muted);
        font-size: 0.88rem;
        margin-bottom: 5px;
      }

      .meter-bar {
        width: 100%;
        height: 11px;
        background: rgba(8, 12, 26, 0.7);
        border-radius: 9px;
        overflow: hidden;
      }

      .meter-fill {
        height: 100%;
        transition: width 0.35s ease;
      }

      .hp-fill {
        background: var(--hp);
      }

      .mp-fill {
        background: var(--mp);
      }

      .status-tag {
        display: inline-block;
        background: rgba(255, 255, 255, 0.07);
        padding: 6px 10px;
        border-radius: 10px;
        border: 1px solid var(--line);
        color: var(--muted);
        margin-top: 6px;
        font-size: 0.82rem;
      }

      .middle-layer {
        position: relative;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding: 0 18px;
        min-height: 230px;
      }

      .log-panel {
        position: absolute;
        top: 8px;
        left: 18px;
        width: 280px;
        max-height: 170px;
        background: var(--panel);
        border-radius: 14px;
        border: 1px solid var(--line);
        padding: 10px;
        box-shadow: var(--shadow);
        display: flex;
        flex-direction: column;
      }

      .log-panel h3 {
        color: var(--secondary);
        margin-bottom: 8px;
        font-size: 1rem;
      }

      .log-body {
        flex: 1;
        overflow: hidden;
        display: flex;
        flex-direction: column-reverse;
        gap: 6px;
        max-height: 120px;
      }

      .log-line {
        background: rgba(255, 255, 255, 0.04);
        padding: 9px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.05);
        color: var(--text);
      }

      .arena-center {
        display: flex;
        align-items: flex-start;
        justify-content: center;
        width: 100%;
        padding-top: 4px;
      }

      .hero-row {
        position: relative;
        display: flex;
        justify-content: center;
        gap: 12px;
        padding: 10px 16px 0;
        flex-wrap: wrap;
      }

      .hero-card {
        width: 220px;
        background: var(--card);
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        padding: 10px;
        box-shadow: var(--shadow);
        transition: transform 0.3s ease, box-shadow 0.3s ease,
          border-color 0.3s ease;
      }

      .hero-card.active {
        transform: translateY(-10px) scale(1.03);
        border-color: var(--primary);
        box-shadow: 0 20px 40px rgba(116, 240, 237, 0.28);
      }

      .hero-top {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .hero-avatar {
        width: 60px;
        height: 60px;
        border-radius: 12px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: #0c142f;
      }

      .hero-avatar img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      .hero-name {
        font-size: 1.02rem;
      }

      .hero-role {
        color: var(--muted);
        font-size: 0.88rem;
      }

      .stat-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 6px;
        margin-top: 8px;
      }

      .stat-chip {
        text-align: center;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 8px;
        padding: 5px 4px;
        color: var(--muted);
        font-size: 0.83rem;
      }

      .stat-chip strong {
        display: block;
        color: var(--text);
      }

      .skill-bar {
        margin: 8px auto 0;
        width: clamp(780px, 70vw, 920px);
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid var(--line);
        border-radius: 14px;
        padding: 8px 10px;
        box-shadow: var(--shadow);
        display: flex;
        flex-direction: column;
        gap: 8px;
        position: relative;
      }

      .skill-buttons {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 8px;
      }

      .skill-button {
        background: linear-gradient(
          135deg,
          rgba(116, 240, 237, 0.2),
          rgba(116, 240, 237, 0.1)
        );
        border: 1px solid rgba(116, 240, 237, 0.4);
        border-radius: 10px;
        padding: 8px;
        color: var(--text);
        cursor: pointer;
        text-align: left;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        font-size: 0.97rem;
      }

      .skill-button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 10px 18px rgba(116, 240, 237, 0.25);
      }

      .skill-button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .skill-meta {
        display: flex;
        justify-content: space-between;
        color: var(--muted);
        font-size: 0.88rem;
      }

      .skill-info {
        background: var(--panel);
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 9px 10px;
        color: var(--text);
        box-shadow: var(--shadow);
        font-size: 0.96rem;
        position: absolute;
        left: 0;
        top: 0;
        max-width: 260px;
        z-index: 5;
        pointer-events: none;
      }

      .skill-info h4 {
        color: var(--secondary);
        margin-bottom: 6px;
      }

      .target-layer {
        position: fixed;
        inset: 0;
        background: rgba(5, 9, 18, 0.7);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 150;
      }

      .target-window {
        background: var(--card);
        padding: 24px;
        border-radius: 16px;
        border: 1px solid var(--line);
        box-shadow: var(--shadow);
        width: min(480px, 92vw);
      }

      .target-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        margin-bottom: 12px;
      }

      .target-window h3 {
        color: var(--secondary);
        margin-bottom: 12px;
      }

      .target-cancel {
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.12);
        color: var(--text);
        border-radius: 10px;
        width: 36px;
        height: 36px;
        cursor: pointer;
        font-size: 1rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s ease, transform 0.2s ease;
      }

      .target-cancel:hover {
        background: rgba(255, 200, 87, 0.12);
        color: var(--secondary);
        transform: translateY(-1px);
      }

      .target-options {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .target-btn {
        flex: 1 1 45%;
        padding: 12px 10px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        color: var(--text);
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .target-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 20px rgba(0, 0, 0, 0.35);
      }

      .targetable {
        border-color: var(--secondary) !important;
        box-shadow: 0 16px 30px rgba(255, 200, 87, 0.2), var(--shadow);
        animation: targetPulse 1.2s ease-in-out infinite;
      }

      @keyframes targetPulse {
        0% {
          box-shadow: 0 12px 26px rgba(255, 200, 87, 0.08), var(--shadow);
        }
        50% {
          box-shadow: 0 14px 30px rgba(255, 200, 87, 0.2), var(--shadow);
        }
        100% {
          box-shadow: 0 12px 26px rgba(255, 200, 87, 0.08), var(--shadow);
        }
      }

      .footer-row {
        position: relative;
        z-index: 3;
        padding: 0 16px 18px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }

      .waiting-text {
        color: var(--muted);
        text-align: center;
      }

      .game-over {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.82);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 190;
      }

      .game-over-card {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 20px;
        padding: 32px;
        text-align: center;
        box-shadow: var(--shadow);
        width: min(520px, 92vw);
      }

      .victory {
        color: var(--primary);
      }
      .defeat {
        color: var(--accent);
      }

      .restart {
        margin-top: 16px;
        padding: 10px 20px;
        border: none;
        border-radius: 12px;
        background: linear-gradient(
          135deg,
          rgba(255, 200, 87, 0.9),
          rgba(255, 200, 87, 0.6)
        );
        color: #261402;
        font-weight: 700;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div class="game-shell">
      <div class="start-screen" id="startScreen">
        <div class="start-panel">
          <h1>Celestia Clash</h1>
          <p>
            Turn-based RPG demo. Command your squad and break the dragon's fury.
          </p>
          <button class="start-button" id="startButton">Start</button>
        </div>
      </div>

      <div class="battle-field" id="battleField" style="display: none">
        <div class="nebula"></div>
        <div class="battle-layer">
          <div class="turn-order">
            <div class="turn-track">
              <div class="turn-line"></div>
              <div class="turn-nodes" id="turnNodes"></div>
            </div>
          </div>

          <div class="middle-layer">
            <div class="log-panel">
              <h3 style="text-align: center">Battle Log</h3>
              <div class="log-body" id="logBody"></div>
            </div>
              <div class="arena-center">
            <div class="dragon-area">
                <div class="boss-card" id="bossCard">
                  <div class="boss-top">
                    <div class="boss-avatar">
                      <img src="gif/dragon.gif" alt="Dragon" />
                    </div>
                    <div class="boss-meta">
                      <h2>Obsidian Dragon</h2>
                      <div class="meter">
                        <div class="meter-label">
                          <span>HP</span>
                          <span id="bossHpText">--</span>
                        </div>
                        <div class="meter-bar">
                          <div class="meter-fill hp-fill" id="bossHpBar"></div>
                        </div>
                      </div>
                      <div class="meter">
                        <div class="meter-label">
                          <span>MP</span>
                          <span id="bossMpText">--</span>
                        </div>
                        <div class="meter-bar">
                          <div class="meter-fill mp-fill" id="bossMpBar"></div>
                        </div>
                      </div>
                      <div
                        class="status-tag"
                        id="bossStatus"
                        style="display: none"
                      ></div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="footer-row">
            <div class="hero-row" id="heroRow"></div>
            <div class="skill-bar" id="skillBar">
              <div class="skill-buttons" id="skillButtons"></div>
              <div
                class="skill-info"
                id="skillInfo"
                style="display: none"
              ></div>
              <div class="waiting-text" id="waitingText">Waiting...</div>
            </div>
          </div>
        </div>
      </div>

      <div class="target-layer" id="targetLayer">
        <div class="target-window">
          <div class="target-header">
            <h3>Select a target</h3>
            <button class="target-cancel" id="targetCancel">✕</button>
          </div>
          <div class="target-options" id="targetOptions"></div>
        </div>
      </div>

      <div class="game-over" id="gameOver">
        <div class="game-over-card">
          <h2 id="gameOverTitle" class="victory">Victory</h2>
          <p id="gameOverText">Your team stands triumphant!</p>
          <button class="restart" id="restart">Restart</button>
        </div>
      </div>
    </div>

    <script>
      const heroConfigs = [
        {
          id: "soldier",
          name: "Soldier",
          role: "Physical DPS",
          maxHp: 150,
          maxMp: 60,
          atk: 34,
          def: 14,
          mag: 6,
          spd: 12,
          skills: [
            {
              id: "basicSlash",
              name: "Basic Attack",
              cost: 0,
              target: "enemy",
              type: "physical",
              power: 0.9,
              description: "Reliable strike when MP is low.",
            },
            {
              id: "powerSlash",
              name: "Power Slash",
              cost: 14,
              target: "enemy",
              type: "physical",
              power: 1.4,
              description: "Heavy physical blow dealing strong damage.",
            },
            {
              id: "armorBreak",
              name: "Armor Break",
              cost: 16,
              target: "enemy",
              type: "physical",
              power: 1.1,
              debuff: { defDown: 0.2, duration: 2 },
              description:
                "Strike that reduces the dragon's defense for 2 turns.",
            },
            {
              id: "rally",
              name: "Rally",
              cost: 10,
              target: "allies",
              type: "buff",
              buff: { atkUp: 0.2, duration: 2 },
              description: "Encourage allies, boosting attack for 2 turns.",
            },
          ],
        },
        {
          id: "mage",
          name: "Mage",
          role: "Magic DPS",
          maxHp: 110,
          maxMp: 120,
          atk: 10,
          def: 10,
          mag: 40,
          spd: 14,
          skills: [
            {
              id: "arcaneBolt",
              name: "Arcane Bolt",
              cost: 12,
              target: "enemy",
              type: "magic",
              power: 1.3,
              description: "Precise arcane shot of pure energy.",
            },
            {
              id: "firestorm",
              name: "Firestorm",
              cost: 22,
              target: "all-enemies",
              type: "magic",
              power: 1.1,
              description:
                "AoE inferno that scorches the dragon and leaves burning embers.",
              dot: { amount: 6, duration: 2 },
            },
            {
              id: "manaSurge",
              name: "Mana Surge",
              cost: 18,
              target: "self",
              type: "buff",
              buff: { magUp: 0.3, duration: 2 },
              description: "Channel energy to boost magic for 2 turns.",
            },
            {
              id: "weakSpark",
              name: "Weak Spark",
              cost: 6,
              target: "enemy",
              type: "magic",
              power: 0.8,
              description: "Low-cost spark to conserve mana.",
            },
          ],
        },
        {
          id: "healer",
          name: "Healer",
          role: "Support",
          maxHp: 140,
          maxMp: 90,
          atk: 12,
          def: 16,
          mag: 24,
          spd: 10,
          skills: [
            {
              id: "singleHeal",
              name: "Single Heal",
              cost: 14,
              target: "ally",
              type: "heal",
              power: 1.0,
              description: "Restore a large amount of HP to one ally.",
            },
            {
              id: "groupHeal",
              name: "Group Heal",
              cost: 18,
              target: "allies",
              type: "heal",
              power: 0.7,
              description: "Restore moderate HP to all allies.",
            },
            {
              id: "cleanse",
              name: "Cleanse",
              cost: 12,
              target: "ally",
              type: "cleanse",
              description: "Remove harmful debuffs from one ally.",
            },
            {
              id: "lightStrike",
              name: "Light Strike",
              cost: 4,
              target: "enemy",
              type: "magic",
              power: 0.6,
              description: "Gentle strike of light magic.",
            },
          ],
        },
        {
          id: "tank",
          name: "Tank",
          role: "Defender",
          maxHp: 220,
          maxMp: 60,
          atk: 18,
          def: 28,
          mag: 8,
          spd: 8,
          skills: [
            {
              id: "bash",
              name: "Bash",
              cost: 8,
              target: "enemy",
              type: "physical",
              power: 1.0,
              description: "Shield bash with chance to shake the dragon.",
              debuff: { dmgDown: 0.15, duration: 1 },
            },
            {
              id: "guard",
              name: "Guard",
              cost: 10,
              target: "self",
              type: "buff",
              buff: { guard: 0.4, duration: 1 },
              description:
                "Brace for impact, cutting incoming damage this turn.",
            },
            {
              id: "taunt",
              name: "Provoke",
              cost: 12,
              target: "self",
              type: "taunt",
              duration: 2,
              description: "Draw the dragon's focus for 2 turns.",
            },
            {
              id: "shieldWall",
              name: "Shield Wall",
              cost: 16,
              target: "allies",
              type: "buff",
              buff: { guardTeam: 0.2, duration: 2 },
              description:
                "Raise shields for the whole squad, reducing damage for 2 turns.",
            },
          ],
        },
      ];

      const bossConfig = {
        id: "boss",
        name: "Obsidian Dragon",
        maxHp: 2200,
        maxMp: 200,
        atk: 42,
        def: 24,
        mag: 36,
        spd: 11,
        status: {},
        skills: [
          {
            id: "crushingClaw",
            name: "Crushing Claw",
            cost: 0,
            type: "physical",
            power: 1.1,
            pattern: "single",
            weight: 4,
          },
          {
            id: "fieryRend",
            name: "Fiery Rend",
            cost: 22,
            type: "magic",
            power: 1.8,
            splashPower: 0.7,
            pattern: "single-splash",
            weight: 3,
          },
          {
            id: "cinderWave",
            name: "Cinder Wave",
            cost: 18,
            type: "magic",
            power: 1.15,
            pattern: "aoe",
            weight: 3,
          },
          {
            id: "obliterate",
            name: "Obliterate",
            cost: 32,
            type: "physical",
            power: 2.4,
            pattern: "single",
            weight: 1,
          },
        ],
      };

      class Game {
        constructor() {
          this.heroes = heroConfigs.map((h) => ({
            ...h,
            hp: h.maxHp,
            mp: h.maxMp,
            status: {},
          }));
          this.boss = {
            ...bossConfig,
            hp: bossConfig.maxHp,
            mp: bossConfig.maxMp,
          };
          this.turnOrder = [];
          this.turnIndex = 0;
          this.state = "menu";
          this.pendingSkill = null;
          this.bossWindupSkill = null;
          this.logEl = document.getElementById("logBody");
          this.heroRow = document.getElementById("heroRow");
          this.skillBar = document.getElementById("skillBar");
          this.skillButtons = document.getElementById("skillButtons");
          this.skillInfo = document.getElementById("skillInfo");
          this.waitingText = document.getElementById("waitingText");
          this.turnNodes = document.getElementById("turnNodes");
          this.targetLayer = document.getElementById("targetLayer");
          this.targetOptions = document.getElementById("targetOptions");
          this.targetCancel = document.getElementById("targetCancel");
          this.bossCard = document.getElementById("bossCard");
          this.bossEnragedNotified = false;
          this.bossEnraged = false;
          this.targeting = false;
          this.bindMenu();
          this.renderHeroes();
          this.rebuildTurnOrder();
          this.updateUI();
        }

        bindMenu() {
          document
            .getElementById("startButton")
            .addEventListener("click", () => {
              document.getElementById("startScreen").style.display = "none";
              document.getElementById("battleField").style.display = "block";
              this.state = "playing";
              this.startTurn();
            });

          document.getElementById("restart").addEventListener("click", () => {
            this.reset();
          });

          this.targetCancel.addEventListener("click", () => {
            this.cancelTargetSelection();
          });
        }

        reset() {
          this.heroes = heroConfigs.map((h) => ({
            ...h,
            hp: h.maxHp,
            mp: h.maxMp,
            status: {},
          }));
          this.boss = {
            ...bossConfig,
            hp: bossConfig.maxHp,
            mp: bossConfig.maxMp,
            status: {},
          };
          this.turnIndex = 0;
          this.state = "playing";
          this.pendingSkill = null;
          this.bossEnragedNotified = false;
          this.bossEnraged = false;
          this.bossWindupSkill = null;
          this.targeting = false;
          this.closeTargetSelect();
          document.getElementById("gameOver").style.display = "none";
          this.logEl.innerHTML = "";
          this.renderHeroes();
          this.rebuildTurnOrder();
          this.updateUI();
          this.startTurn();
        }

        renderHeroes() {
          this.heroRow.innerHTML = "";
          this.heroes.forEach((hero) => {
            const card = document.createElement("div");
            card.className = "hero-card";
            card.id = `${hero.id}Card`;
            card.innerHTML = `
              <div class="hero-top">
                <div class="hero-avatar"><img src="gif/${hero.id}.gif" alt="${hero.name}" /></div>
                <div>
                  <div class="hero-name">${hero.name}</div>
                  <div class="hero-role">${hero.role}</div>
                  <div class="status-tag" id="${hero.id}Status" style="display:none"></div>
                </div>
              </div>
              <div class="meter" style="margin-top:10px;">
                <div class="meter-label"><span>HP</span><span id="${hero.id}HpText"></span></div>
                <div class="meter-bar"><div class="meter-fill hp-fill" id="${hero.id}HpBar"></div></div>
              </div>
              <div class="meter" style="margin-top:8px;">
                <div class="meter-label"><span>MP</span><span id="${hero.id}MpText"></span></div>
                <div class="meter-bar"><div class="meter-fill mp-fill" id="${hero.id}MpBar"></div></div>
              </div>
              <div class="stat-grid">
                <div class="stat-chip">ATK<strong>${hero.atk}</strong></div>
                <div class="stat-chip">DEF<strong>${hero.def}</strong></div>
                <div class="stat-chip">MAG<strong>${hero.mag}</strong></div>
                <div class="stat-chip">SPD<strong>${hero.spd}</strong></div>
              </div>
            `;
            this.heroRow.appendChild(card);
          });
        }

        log(message) {
          const entry = document.createElement("div");
          entry.className = "log-line";
          entry.textContent = message;
          this.logEl.prepend(entry);
          const maxEntries = 6;
          while (this.logEl.children.length > maxEntries) {
            this.logEl.removeChild(this.logEl.lastElementChild);
          }
        }

        getHero(id) {
          return this.heroes.find((h) => h.id === id);
        }

        startTurn() {
          if (this.state !== "playing") return;
          this.applyDurations();
          const current = this.turnOrder[this.turnIndex];
          this.highlightTurn();
          if (current === "boss") {
            this.waitingText.textContent = "Dragon is acting...";
            this.skillButtons.innerHTML = "";
            this.skillInfo.style.display = "none";
            setTimeout(() => this.dragonAct(), 700);
          } else {
            const hero = this.getHero(current);
            if (hero.hp <= 0) {
              this.advanceTurn();
              return;
            }
            this.waitingText.textContent = `${hero.name}'s turn`;
            this.renderSkillBar(hero);
          }
        }

        highlightTurn() {
          this.heroes.forEach((hero) => {
            const card = document.getElementById(`${hero.id}Card`);
            if (this.turnOrder[this.turnIndex] === hero.id && hero.hp > 0) {
              card.classList.add("active");
            } else {
              card.classList.remove("active");
            }
          });
          this.renderTurnNodes();
        }

        rebuildTurnOrder() {
          const livingUnits = [...this.heroes, this.boss].filter((u) => u.hp > 0);
          livingUnits.sort((a, b) => (b.spd || 10) - (a.spd || 10));
          this.turnOrder = livingUnits.map((u) => u.id);
          this.turnIndex = 0;
          this.renderTurnNodes();
        }

        renderTurnNodes() {
          this.turnNodes.innerHTML = "";
          for (let i = 0; i < this.turnOrder.length; i++) {
            const idx = (this.turnIndex + i) % this.turnOrder.length;
            const id = this.turnOrder[idx];
            const node = document.createElement("div");
            node.className = "turn-node" + (i === 0 ? " active" : "");
            const img = document.createElement("img");
            const src = id === "boss" ? "gif/dragon.gif" : `gif/${id}.gif`;
            img.src = src;
            img.alt = id;
            node.appendChild(img);
            this.turnNodes.appendChild(node);
          }
        }

        renderSkillBar(hero) {
          this.skillButtons.innerHTML = "";
          this.skillInfo.style.display = "none";
          hero.skills.forEach((skill) => {
            const btn = document.createElement("button");
            btn.className = "skill-button";
            btn.innerHTML = `<div><strong>${skill.name}</strong></div>
              <div class="skill-meta"><span>${skill.target}</span><span>MP ${skill.cost}</span></div>`;
            btn.disabled = hero.mp < skill.cost || hero.hp <= 0;
            btn.addEventListener("mouseenter", () => {
              this.showSkillInfo(skill, btn);
            });
            btn.addEventListener("mouseleave", () => {
              this.hideSkillInfo();
            });
            btn.addEventListener("click", () => {
              this.pendingSkill = { hero, skill };
              this.prepareTargeting(hero, skill);
            });
            this.skillButtons.appendChild(btn);
          });
        }

        showSkillInfo(skill, button) {
          const targetLabel =
            skill.target === "enemy"
              ? "Single Target"
              : skill.target === "all-enemies"
              ? "AoE Enemy"
              : skill.target === "ally"
              ? "Ally"
              : skill.target === "allies"
              ? "All Allies"
              : "Self";
          this.skillInfo.innerHTML = `
            <h4>${skill.name}</h4>
            <div style="color:var(--muted);margin-bottom:6px;">${targetLabel} · MP ${skill.cost}</div>
            <p>${skill.description}</p>
          `;
          this.skillInfo.style.display = "block";
          const btnRect = button.getBoundingClientRect();
          const barRect = this.skillBar.getBoundingClientRect();
          const tooltipWidth = this.skillInfo.offsetWidth;
          const left = Math.min(
            Math.max(btnRect.left - barRect.left + btnRect.width / 2 - tooltipWidth / 2, 8),
            barRect.width - tooltipWidth - 8
          );
          const top = Math.max(
            btnRect.top - barRect.top - this.skillInfo.offsetHeight - 8,
            8
          );
          this.skillInfo.style.left = `${left}px`;
          this.skillInfo.style.top = `${top}px`;
        }

        hideSkillInfo() {
          this.skillInfo.style.display = "none";
        }

        prepareTargeting(hero, skill) {
          if (["self", "allies", "all-enemies"].includes(skill.target)) {
            this.executeSkill(hero, skill);
          } else if (skill.target === "enemy") {
            this.executeSkill(hero, skill, this.boss);
          } else {
            this.openTargetSelect(
              skill.target === "ally"
                ? this.heroes.filter((h) => h.hp > 0)
                : [this.boss],
              (target) => {
                this.executeSkill(hero, skill, target);
              }
            );
          }
        }

        openTargetSelect(options, callback) {
          this.targetOptions.innerHTML = "";
          options.forEach((t) => {
            const btn = document.createElement("button");
            btn.className = "target-btn";
            btn.textContent = t.name;
            btn.addEventListener("click", () => {
              this.closeTargetSelect();
              callback(t);
            });
            this.targetOptions.appendChild(btn);
          });
          this.setTargetHighlights(options);
          this.targeting = true;
          this.targetLayer.style.display = "flex";
        }

        closeTargetSelect() {
          this.targetLayer.style.display = "none";
          this.targetOptions.innerHTML = "";
          this.clearTargetHighlights();
          this.targeting = false;
        }

        setTargetHighlights(targets) {
          this.clearTargetHighlights();
          targets.forEach((t) => {
            if (t.id === "boss" && this.bossCard) {
              this.bossCard.classList.add("targetable");
            } else {
              const card = document.getElementById(`${t.id}Card`);
              if (card) card.classList.add("targetable");
            }
          });
        }

        clearTargetHighlights() {
          document
            .querySelectorAll(".targetable")
            .forEach((el) => el.classList.remove("targetable"));
        }

        cancelTargetSelection() {
          if (!this.targeting) return;
          const current = this.turnOrder[this.turnIndex];
          if (current !== "boss") {
            const hero = this.getHero(current);
            if (hero) this.waitingText.textContent = `${hero.name}'s turn`;
          }
          this.pendingSkill = null;
          this.skillInfo.style.display = "none";
          this.closeTargetSelect();
        }

        applyDurations() {
          const decay = (status) => {
            Object.keys(status).forEach((k) => {
              // DOT is decayed in resolveDot to ensure it ticks for its full duration
              if (k === "dot") return;
              if (status[k] && typeof status[k].duration === "number") {
                status[k].duration -= 1;
                if (status[k].duration <= 0) delete status[k];
              }
            });
          };
          this.heroes.forEach((h) => decay(h.status || {}));
          decay(this.boss.status || {});
        }

        applyEndOfTurnRegen() {
          this.heroes.forEach((h) => {
            if (h.hp > 0) {
              const regen = 3;
              h.mp = Math.min(h.maxMp, h.mp + regen);
            }
          });
          this.boss.mp = Math.min(this.boss.maxMp, this.boss.mp + 4);
        }

        computeDefense(target) {
          const baseDef = target.id === "boss" ? this.boss.def : target.def;
          let modifier = 1;

          if (target.status?.defDown) {
            modifier -= target.status.defDown.amount;
          }

          return Math.max(1, Math.round(baseDef * modifier));
        }

        applyDamage(source, target, skill) {
          const isMagic = skill.type === "magic";
          const attackStat = isMagic ? source.mag : source.atk;
          const defense = this.computeDefense(target);
          let base = Math.max(0, attackStat - defense * 0.5);
          const power = skill.power || 1;
          let buffMulti = 1;
          if (source.status.atkUp && !isMagic)
            buffMulti += source.status.atkUp.amount;
          if (source.status.magUp && isMagic)
            buffMulti += source.status.magUp.amount;
          if (target.status.dmgDown) buffMulti -= target.status.dmgDown.amount;
          const guardCut = target.status.guard?.amount || 0;
          const guardTeam = target.status.guardTeam?.amount || 0;
          let synergyMulti = 1;
          if (!isMagic && target.status?.defDown) synergyMulti += 0.15;
          if (source.id === "tank" && this.boss.status?.dot && target.id === "boss")
            synergyMulti += 0.1;
          const enrageMultiplier =
            source.id === "boss" && this.isDragonEnraged() ? 2 : 1;
          const damage = Math.max(
            8,
            Math.round(
              base *
                power *
                buffMulti *
                synergyMulti *
                (1 - guardCut - guardTeam)
            )
          );
          const finalDamage = Math.max(
            8,
            Math.round(damage * enrageMultiplier)
          );
          target.hp = Math.max(0, target.hp - finalDamage);
          if (skill.debuff) {
            target.status = target.status || {};
            Object.keys(skill.debuff).forEach((key) => {
              if (key !== "duration") {
                target.status[key] = {
                  amount: skill.debuff[key],
                  duration: skill.debuff.duration,
                };
              }
            });
          }
          if (skill.dot) {
            target.status = target.status || {};
            target.status.dot = {
              amount: skill.dot.amount,
              duration: skill.dot.duration,
            };
          }
          return finalDamage;
        }

        applyHeal(source, target, skill) {
          const power = skill.power || 0.5;
          const base = target.maxHp * 0.35;
          const amount = Math.round(base * power);
          target.hp = Math.min(target.maxHp, target.hp + amount);
          return amount;
        }

        executeSkill(user, skill, target = null) {
          if (user.mp < skill.cost) return;
          user.mp -= skill.cost;
          if (!target) target = skill.target === "self" ? user : null;

          if (skill.type === "physical" || skill.type === "magic") {
            const tgt = target || this.boss;
            const dmg = this.applyDamage(user, tgt, skill);
            const name = tgt.id === "boss" ? this.boss.name : tgt.name;
            this.log(
              `${user.name} used ${skill.name} on ${name} for ${dmg} damage.`
            );
            if (skill.execute && tgt.hp / tgt.maxHp < skill.execute) {
              tgt.hp = Math.max(0, tgt.hp - 40);
              this.log(`${skill.name} bites harder against weakened foes!`);
            }
          } else if (skill.type === "heal") {
            if (skill.target === "allies") {
              this.heroes.forEach((h) => {
                if (h.hp > 0) {
                  const healed = this.applyHeal(user, h, skill);
                  this.log(`${user.name} heals ${h.name} for ${healed}.`);
                }
              });
            } else if (target) {
              const healed = this.applyHeal(user, target, skill);
              this.log(`${user.name} heals ${target.name} for ${healed}.`);
            }
          } else if (skill.type === "buff") {
            const applyBuff = (t) => {
              t.status = t.status || {};
              Object.keys(skill.buff).forEach((key) => {
                if (key !== "duration") {
                  t.status[key] = {
                    amount: skill.buff[key],
                    duration: skill.buff.duration,
                  };
                }
              });
            };
            if (skill.target === "allies") this.heroes.forEach(applyBuff);
            else applyBuff(target || user);
            this.log(`${user.name} uses ${skill.name} to empower allies.`);
          } else if (skill.type === "cleanse" && target) {
            target.status = {};
            this.log(`${user.name} cleansed ${target.name}.`);
          } else if (skill.type === "taunt") {
            this.boss.status.taunt = {
              amount: 1,
              duration: skill.duration,
              target: user.id,
            };
            this.log(`${user.name} provokes the dragon!`);
          }

          this.resolveDot();
          this.updateUI();
          this.checkEnd();
          if (this.state === "playing") {
            this.advanceTurn();
          }
        }

        resolveDot() {
          if (this.boss.status?.dot) {
            const dot = this.boss.status.dot;
            this.boss.hp = Math.max(0, this.boss.hp - dot.amount);
            this.log(`Burning embers scorch the dragon for ${dot.amount}.`);
            dot.duration -= 1;
            if (dot.duration <= 0) {
              delete this.boss.status.dot;
              this.log("The flames die down around the dragon.");
            }
          }
        }

        dragonAct() {
          const boss = this.boss;
          const aliveHeroes = this.heroes.filter((h) => h.hp > 0);
          if (!aliveHeroes.length) {
            this.checkEnd();
            return;
          }

          this.isDragonEnraged();
          let choice = this.bossWindupSkill;

          if (!choice) {
            choice = this.chooseDragonSkill();
            if (this.bossEnraged && choice.pattern === "aoe") {
              this.log("The dragon inhales sharply, flames gathering in its throat!");
              this.bossWindupSkill = choice;
              this.advanceTurn();
              return;
            }
          } else {
            this.log("The dragon unleashes its stored power in a blazing roar!");
            this.bossWindupSkill = null;
          }

          boss.mp = Math.max(0, boss.mp - choice.cost);

          if (choice.pattern === "aoe") {
            aliveHeroes.forEach((hero) => {
              if (hero.hp > 0) {
                const dmg = this.applyDamage(boss, hero, choice);
                this.log(`Dragon scorched ${hero.name} for ${dmg} damage.`);
              }
            });
          } else if (choice.pattern === "single-splash") {
            const targetHero =
              this.selectDragonTarget(aliveHeroes) || aliveHeroes[0];
            const mainDmg = this.applyDamage(boss, targetHero, choice);
            this.log(
              `Dragon unleashed a fiery blast on ${targetHero.name} for ${mainDmg} damage.`
            );
            aliveHeroes
              .filter((h) => h.id !== targetHero.id)
              .forEach((hero) => {
                const splashSkill = { ...choice, power: choice.splashPower };
                const splashDmg = this.applyDamage(boss, hero, splashSkill);
                this.log(
                  `Splash fire singed ${hero.name} for ${splashDmg} damage.`
                );
              });
          } else {
            const targetHero =
              this.selectDragonTarget(aliveHeroes) || aliveHeroes[0];
            const dmg = this.applyDamage(boss, targetHero, choice);
            if (choice.id === "obliterate") {
              this.log(
                `Dragon used a devastating attack on ${targetHero.name} for ${dmg} damage.`
              );
            } else {
              this.log(
                `Dragon attacked ${targetHero.name} with a basic strike for ${dmg} damage.`
              );
            }
          }

          this.resolveDot();
          this.updateUI();
          this.checkEnd();
          if (this.state === "playing") this.advanceTurn();
        }

        chooseDragonSkill() {
          const enraged = this.isDragonEnraged() || this.bossEnraged;
          const weightedSkills = (enraged
            ? this.boss.skills.map((s) => ({
                ...s,
                weight:
                  s.id === "cinderWave"
                    ? (s.weight || 1) + 2
                    : s.id === "fieryRend"
                    ? (s.weight || 1) + 1
                    : s.id === "obliterate"
                    ? (s.weight || 1) + 1
                    : s.weight || 1,
              }))
            : this.boss.skills
          ).filter((s) => s.cost === 0 || this.boss.mp >= s.cost);

          const pool = weightedSkills.length
            ? weightedSkills
            : [this.boss.skills[0]];
          const weighted = [];
          pool.forEach((skill) => {
            const weight = skill.weight || 1;
            for (let i = 0; i < weight; i++) weighted.push(skill);
          });
          return weighted[Math.floor(Math.random() * weighted.length)];
        }

        selectDragonTarget(aliveHeroes) {
          if (!aliveHeroes.length) return null;
          const tauntTarget =
            this.boss.status.taunt &&
            this.getHero(this.boss.status.taunt.target);
          if (tauntTarget && tauntTarget.hp > 0 && Math.random() < 0.7) {
            this.log(
              `Dragon is provoked and focuses the ${tauntTarget.name}!`
            );
            return tauntTarget;
          }
          return aliveHeroes.reduce((lowest, hero) => {
            return hero.hp / hero.maxHp < lowest.hp / lowest.maxHp
              ? hero
              : lowest;
          }, aliveHeroes[0]);
        }

        isDragonEnraged() {
          const enraged = this.boss.hp <= this.boss.maxHp * 0.5;
          if (enraged && !this.bossEnragedNotified) {
            this.log(`${this.boss.name} is enraged! Its damage surges.`);
            this.bossEnragedNotified = true;
          }
          if (enraged) this.bossEnraged = true;
          return enraged;
        }

        advanceTurn() {
          const nextIndex = (this.turnIndex + 1) % this.turnOrder.length;
          this.applyEndOfTurnRegen();
          if (nextIndex === 0) {
            this.rebuildTurnOrder();
          } else {
            this.turnIndex = nextIndex;
          }
          this.updateUI();
          setTimeout(() => this.startTurn(), 600);
        }

        updateUI() {
          const bossHpPct = (this.boss.hp / this.boss.maxHp) * 100;
          const bossMpPct = (this.boss.mp / this.boss.maxMp) * 100;
          document.getElementById("bossHpBar").style.width = `${bossHpPct}%`;
          document.getElementById("bossMpBar").style.width = `${bossMpPct}%`;
          document.getElementById(
            "bossHpText"
          ).textContent = `${this.boss.hp}/${this.boss.maxHp}`;
          document.getElementById(
            "bossMpText"
          ).textContent = `${this.boss.mp}/${this.boss.maxMp}`;
          const bossStatus = document.getElementById("bossStatus");
          const bossLabels = [];
          if (this.boss.status?.dot)
            bossLabels.push(`Burning (${this.boss.status.dot.duration})`);
          if (this.boss.status?.defDown)
            bossLabels.push(`DEF↓ (${this.boss.status.defDown.duration})`);
          if (this.boss.status?.taunt)
            bossLabels.push(`Provoked (${this.boss.status.taunt.duration})`);
          bossStatus.style.display = bossLabels.length ? "inline-block" : "none";
          bossStatus.textContent = bossLabels.join(" · ");

          this.heroes.forEach((h) => {
            const hpPct = (h.hp / h.maxHp) * 100;
            const mpPct = (h.mp / h.maxMp) * 100;
            document.getElementById(`${h.id}HpBar`).style.width = `${hpPct}%`;
            document.getElementById(`${h.id}MpBar`).style.width = `${mpPct}%`;
            document.getElementById(
              `${h.id}HpText`
            ).textContent = `${h.hp}/${h.maxHp}`;
            document.getElementById(
              `${h.id}MpText`
            ).textContent = `${h.mp}/${h.maxMp}`;
            const status = document.getElementById(`${h.id}Status`);
            const labels = [];
            if (h.status.atkUp) labels.push("ATK↑");
            if (h.status.magUp) labels.push("MAG↑");
            if (h.status.guard) labels.push("Guard");
            if (h.status.guardTeam) labels.push("Shielded");
            if (h.status.atkDown) labels.push("ATK↓");
            if (h.status.defDown) labels.push("DEF↓");
            status.textContent = labels.join(" · ");
            status.style.display = labels.length ? "inline-block" : "none";
          });
        }

        checkEnd() {
          const heroesAlive = this.heroes.some((h) => h.hp > 0);
          if (this.boss.hp <= 0) {
            this.state = "victory";
            document.getElementById("gameOver").style.display = "flex";
            document.getElementById("gameOverTitle").textContent = "Victory";
            document.getElementById("gameOverTitle").className = "victory";
            document.getElementById("gameOverText").textContent =
              "The dragon collapses under your tactics.";
          } else if (!heroesAlive) {
            this.state = "defeat";
            document.getElementById("gameOver").style.display = "flex";
            document.getElementById("gameOverTitle").textContent = "Defeat";
            document.getElementById("gameOverTitle").className = "defeat";
            document.getElementById("gameOverText").textContent =
              "Your party falls to the dragon's rage.";
          }
        }
      }

      new Game();
    </script>
  </body>
</html>
